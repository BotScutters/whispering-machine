<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Whispering Machine - Debug UI</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            overflow-x: hidden;
        }

        .header {
            background: #1a1a1a;
            padding: 1rem;
            border-bottom: 2px solid #333;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header h1 {
            color: #00ff88;
            margin-bottom: 0.5rem;
        }

        .status-bar {
            display: flex;
            gap: 2rem;
            align-items: center;
            font-size: 0.9rem;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #333;
        }

        .status-indicator.connected {
            background: #00ff88;
            box-shadow: 0 0 10px #00ff88;
        }

        .status-indicator.error {
            background: #ff4444;
            box-shadow: 0 0 10px #ff4444;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            padding: 1rem;
        }

        .panel {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .panel h2 {
            color: #00ff88;
            margin-bottom: 1rem;
            font-size: 1.2rem;
        }

        .chart-container {
            position: relative;
            height: 200px;
            margin-bottom: 1rem;
        }

        .time-controls {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .time-btn {
            padding: 0.25rem 0.75rem;
            background: #333;
            border: 1px solid #555;
            color: #e0e0e0;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .time-btn.active {
            background: #00ff88;
            color: #000;
        }

        .signal-controls {
            margin-bottom: 1rem;
            padding: 1rem;
            background: #222;
            border: 1px solid #444;
            border-radius: 4px;
        }

        .signal-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .signal-tag {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.25rem 0.75rem;
            background: #333;
            border: 1px solid #555;
            border-radius: 4px;
            font-size: 0.85rem;
        }

        .signal-tag .color-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            cursor: pointer;
        }

        .signal-tag .remove-btn {
            cursor: pointer;
            color: #ff4444;
            font-weight: bold;
        }

        .add-signal-form {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            margin-top: 0.5rem;
        }

        .add-signal-form select,
        .add-signal-form input {
            background: #111;
            border: 1px solid #333;
            color: #e0e0e0;
            border-radius: 4px;
            padding: 0.4rem;
        }

        .status-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }

        .status-table th {
            background: #222;
            color: #00ff88;
            padding: 0.5rem;
            text-align: left;
            border: 1px solid #333;
        }

        .status-table td {
            padding: 0.5rem;
            border: 1px solid #333;
            font-family: 'Courier New', monospace;
        }

        .status-table tr:hover {
            background: #222;
        }

        .status-table .signal-name {
            color: #888;
            font-weight: bold;
            cursor: help;
        }

        .tooltip {
            position: relative;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 300px;
            background-color: #1a1a1a;
            color: #e0e0e0;
            text-align: left;
            border-radius: 6px;
            padding: 0.75rem;
            border: 1px solid #00ff88;
            position: fixed;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.85rem;
            pointer-events: none;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        
        /* Position tooltip dynamically via JS to avoid overflow */

        .led-ring {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 1rem 0;
        }

        .led-ring-simulator {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: #222;
            border: 2px solid #444;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .led-pixel {
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #333;
            border: 1px solid #555;
        }

        .mqtt-debugger {
            max-height: 300px;
            overflow-y: auto;
            background: #0a0a0a;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 0.5rem;
        }

        .mqtt-message {
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            margin-bottom: 0.5rem;
            padding: 0.25rem;
            border-left: 3px solid #00ff88;
            background: #111;
        }

        .mqtt-topic {
            color: #00aaff;
            font-weight: bold;
        }

        .mqtt-payload {
            color: #ffaa00;
            margin-left: 1rem;
        }

        .mqtt-timestamp {
            color: #888;
            font-size: 0.7rem;
        }

        .room-status {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 0.5rem;
        }

        .room-card {
            background: #222;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 0.5rem;
            text-align: center;
        }

        .room-card.occupied {
            border-color: #00ff88;
            background: #001100;
        }

        .room-card.empty {
            border-color: #666;
            background: #111;
        }

        .sensor-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #00ff88;
        }

        .sensor-label {
            font-size: 0.8rem;
            color: #888;
            margin-bottom: 0.25rem;
        }

        .button-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 0.5rem;
        }

        .button-card {
            background: #222;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 0.5rem;
            text-align: center;
        }

        .button-count {
            font-size: 1.2rem;
            font-weight: bold;
            color: #ffaa00;
        }

        .full-width {
            grid-column: 1 / -1;
        }

        .system-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 1rem;
        }

        .metric-card {
            background: #222;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 1rem;
            text-align: center;
        }

        .metric-value {
            font-size: 2rem;
            font-weight: bold;
            color: #00ff88;
        }

        .metric-label {
            font-size: 0.8rem;
            color: #888;
            margin-top: 0.25rem;
        }

        .error-message {
            background: #330000;
            border: 1px solid #ff4444;
            color: #ff4444;
            padding: 0.5rem;
            border-radius: 4px;
            margin-bottom: 1rem;
        }

        .connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 0.5rem 1rem;
            background: #333;
            border-radius: 4px;
            font-size: 0.8rem;
        }

        .connection-status.connected {
            background: #001100;
            color: #00ff88;
        }

        .connection-status.disconnected {
            background: #330000;
            color: #ff4444;
        }
    </style>
</head>
<body>
    <div class="connection-status" id="connectionStatus">Connecting...</div>
    <div id="errorBanner" class="error-message" style="display:none;margin:10px">JS error — check console. Details will appear here.</div>
    
    <div class="header">
        <h1>🔧 Whispering Machine - Debug UI</h1>
        <div class="status-bar">
            <div class="status-item">
                <div class="status-indicator" id="wsStatus"></div>
                <span>WebSocket</span>
            </div>
            <div class="status-item">
                <div class="status-indicator" id="mqttStatus"></div>
                <span>MQTT</span>
            </div>
            <div class="status-item">
                <span>House: <strong id="houseId">houseA</strong></span>
            </div>
            <div class="status-item">
                <span>Fabrication: <strong id="fabricationLevel">0%</strong></span>
            </div>
        </div>
    </div>

    <div class="main-content">
        <!-- Audio Features Panel -->
        <div class="panel full-width">
            <h2>📈 Signal Plotting</h2>
            <div class="signal-controls">
                <strong style="color:#00ff88">Active Signals:</strong>
                <div class="signal-list" id="signalList">
                    <!-- Active signals will appear here -->
                </div>
                <div class="add-signal-form">
                    <select id="nodeSelector">
                        <option value="">Select Node...</option>
                    </select>
                    <select id="signalSelector">
                        <option value="">Select Signal...</option>
                        <optgroup label="Audio">
                            <option value="audio.rms">RMS (loudness)</option>
                            <option value="audio.zcr">ZCR (zero-crossing rate)</option>
                            <option value="audio.low">Low Band (0-300Hz)</option>
                            <option value="audio.mid">Mid Band (300-3000Hz)</option>
                            <option value="audio.high">High Band (3000Hz+)</option>
                        </optgroup>
                        <optgroup label="Occupancy">
                            <option value="occupancy.occupied">Occupied (0/1)</option>
                            <option value="occupancy.activity">Activity (0.0-1.0)</option>
                            <option value="occupancy.transitions">Transitions (per sec)</option>
                        </optgroup>
                        <optgroup label="Encoder">
                            <option value="encoder.pos">Position</option>
                            <option value="encoder.delta">Delta</option>
                        </optgroup>
                    </select>
                    <button class="time-btn" id="addSignalBtn">+ Add Signal</button>
                </div>
            </div>
            <div class="time-controls">
                <button class="time-btn active" data-duration="5">5s</button>
                <button class="time-btn" data-duration="30">30s</button>
                <button class="time-btn" data-duration="60">1m</button>
                <button class="time-btn" data-duration="300">5m</button>
                <button class="time-btn" data-duration="3600">1h</button>
                <button class="time-btn" id="logScaleBtn" style="margin-left:1rem">📊 Linear</button>
            </div>
            <div class="chart-container" style="height: 400px">
                <canvas id="audioChart"></canvas>
            </div>
        </div>

        <!-- Audio Status Table -->
        <div class="panel">
            <h2>🎵 Audio Status</h2>
            <div id="audioStatusTable"></div>
        </div>

        <!-- LED Ring Simulator -->
        <div class="panel">
            <h2>💡 LED Ring Simulator</h2>
            <div id="ledRingContainer"></div>
        </div>

        <!-- Occupancy Status -->
        <div class="panel">
            <h2>🚪 Occupancy Status</h2>
            <div id="occupancyTable"></div>
        </div>

        <!-- Encoder/Button Status -->
        <div class="panel">
            <h2>🎛️ Encoder & Button Status</h2>
            <div id="encoderStatus"></div>
            <h3 style="color:#00ff88;margin-top:1rem;font-size:1rem">Button Events</h3>
            <div id="buttonStatus"></div>
        </div>

        <!-- MQTT Debugger -->
        <div class="panel full-width">
            <h2>📡 MQTT Debugger</h2>
            <div class="time-controls">
                <input id="mqttFilter" placeholder="Filter topics (substring or regex)" style="flex:1;background:#111;border:1px solid #333;color:#e0e0e0;border-radius:4px;padding:.4rem" />
                <button id="clearLogBtn" class="time-btn">Clear</button>
            </div>
            <div class="mqtt-debugger" id="mqttDebugger">
                <!-- MQTT messages will be displayed here -->
            </div>
        </div>

        <!-- System Status -->
        <div class="panel full-width">
            <h2>⚙️ System Status</h2>
            <div class="system-metrics">
                <div class="metric-card">
                    <div class="metric-value" id="messageCount">0</div>
                    <div class="metric-label">Messages</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="uptime">00:00:00</div>
                    <div class="metric-label">Uptime</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="lastUpdate">Never</div>
                    <div class="metric-label">Last Update</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="roomCount">0</div>
                    <div class="metric-label">Active Rooms</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class WhisperingMachineDebugUI {
            constructor() {
                console.log('[debug-full] constructor start');
                this.ws = null;
                this.audioChart = null;
                this.audioData = [];
                this.nodeAudioData = {};
                this.roomsState = {};
                this.encoderState = {}; // {nodeId: {pos, delta, ts_ms}}
                this.buttonState = {}; // {nodeId: {pressed, event, ts_ms}}
                this.mqttMessages = [];
                this.mqttFilter = '';
                this.startTime = Date.now();
                this.messageCount = 0;
                this.currentTimeRange = 5; // seconds
                
                // Modular signal tracking
                this.activeSignals = []; // [{id, node, path, color, visible, data: [{x, y}]}]
                this.signalIdCounter = 0;
                this.nodeData = {}; // {nodeId: {audio: {...}, occupancy: {...}, encoder: {...}}}
                this.discoveredNodes = new Set();
                this.colorPalette = [
                    '#00ff88', // Green
                    '#ffaa00', // Orange
                    '#ff4444', // Red
                    '#4444ff', // Blue
                    '#22d3ee', // Cyan
                    '#f472b6', // Pink
                    '#a3e635', // Lime
                    '#fbbf24', // Amber
                    '#8b5cf6', // Purple
                    '#ec4899', // Magenta
                    '#14b8a6', // Teal
                    '#f97316'  // Deep Orange
                ];
                this.useLogScale = false;
                
                this.initErrorHandlers();
                this.initWebSocket();
                try {
                    this.initCharts();
                } catch (e) {
                    console.error('initCharts failed:', e);
                    this.showError('Charts failed to initialize — Chart.js or time adapter may be unavailable.');
                }
                this.initTimeControls();
                this.initMqttControls();
                this.initSignalControls();
                this.loadSignalConfig();
                // Periodic chart refresh for smoother live updates
                setInterval(() => {
                    try { this.updateModularChart(); } catch (e) { /* noop */ }
                }, 300);
                this.startUptimeCounter();
            }

            initErrorHandlers() {
                window.addEventListener('error', (ev) => {
                    const msg = ev?.error?.message || ev?.message || 'Unknown error';
                    this.showError(`Runtime error: ${msg}`);
                });
                window.addEventListener('unhandledrejection', (ev) => {
                    const msg = (ev && (ev.reason?.message || String(ev.reason))) || 'Unhandled promise rejection';
                    this.showError(msg);
                });
            }

            showError(text) {
                const el = document.getElementById('errorBanner');
                if (!el) return;
                el.textContent = text;
                el.style.display = 'block';
            }

            initWebSocket() {
                const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
                console.log('[debug-full] initWebSocket to', `${protocol}//${location.host}`);
                // Main UI WebSocket
                this.ws = new WebSocket(`${protocol}//${location.host}/ws`);
                this.ws.onopen = () => {
                    console.log('[debug-full] /ws connected');
                    this.updateConnectionStatus('connected');
                    this.updateStatusIndicator('wsStatus', true);
                };
                this.ws.onclose = () => {
                    console.log('[debug-full] /ws closed');
                    this.updateConnectionStatus('disconnected');
                    this.updateStatusIndicator('wsStatus', false);
                    setTimeout(() => this.initWebSocket(), 3000);
                };
                this.ws.onerror = () => {
                    console.log('[debug-full] /ws error');
                    this.updateConnectionStatus('error');
                    this.updateStatusIndicator('wsStatus', false);
                };
                this.ws.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        this.handleMessage(data);
                    } catch (error) {
                        console.error('Error parsing WebSocket message:', error);
                    }
                };
                
                // Debug WebSocket for raw MQTT messages
                this.debugWs = new WebSocket(`${protocol}//${location.host}/ws/debug`);
                this.debugWs.onopen = () => {
                    console.log('[debug-full] /ws/debug connected');
                    this.updateStatusIndicator('mqttStatus', true);
                };
                this.debugWs.onclose = () => {
                    console.log('[debug-full] /ws/debug closed');
                    this.updateStatusIndicator('mqttStatus', false);
                    setTimeout(() => this.initWebSocket(), 3000);
                };
                this.debugWs.onerror = () => {
                    console.log('[debug-full] /ws/debug error');
                    this.updateStatusIndicator('mqttStatus', false);
                };
                this.debugWs.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        this.handleDebugMessage(data);
                    } catch (error) {
                        console.error('Error parsing debug WebSocket message:', error);
                    }
                };
            }

            initCharts() {
                // Audio Chart - start with empty datasets, modular system will populate
                const audioCtx = document.getElementById('audioChart').getContext('2d');
                this.audioChart = new Chart(audioCtx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: []
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    displayFormats: {
                                        second: 'HH:mm:ss',
                                        minute: 'HH:mm',
                                        hour: 'HH:mm'
                                    }
                                },
                                ticks: {
                                    color: '#888'
                                },
                                grid: {
                                    color: '#333'
                                }
                            },
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    color: '#888'
                                },
                                grid: {
                                    color: '#333'
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                labels: {
                                    color: '#e0e0e0'
                                },
                                onClick: (e, legendItem, legend) => {
                                    // Click legend to remove signal
                                    const index = legendItem.datasetIndex;
                                    const dataset = legend.chart.data.datasets[index];
                                    if (dataset && dataset.label) {
                                        // Find signal by label (node/path format)
                                        const signal = this.activeSignals.find(s => 
                                            `${s.node}/${s.path}` === dataset.label
                                        );
                                        if (signal) {
                                            this.removeSignal(signal.id);
                                        }
                                    }
                                }
                            }
                        },
                        animation: {
                            duration: 0  // Disable animations for smoother updates
                        }
                    }
                });
            }

            // Removed: LED ring now dynamically initialized in updateLEDRing()

            initTimeControls() {
                const timeButtons = document.querySelectorAll('.time-btn[data-duration]');
                timeButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        timeButtons.forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.currentTimeRange = parseInt(btn.dataset.duration);
                        this.updateModularChart();
                    });
                });
                
                // Log scale toggle
                const logScaleBtn = document.getElementById('logScaleBtn');
                if (logScaleBtn) {
                    logScaleBtn.addEventListener('click', () => {
                        this.useLogScale = !this.useLogScale;
                        logScaleBtn.textContent = this.useLogScale ? '📊 Log' : '📊 Linear';
                        if (this.audioChart) {
                            this.audioChart.options.scales.y.type = this.useLogScale ? 'logarithmic' : 'linear';
                            this.audioChart.update();
                        }
                    });
                }
            }

            initMqttControls() {
                const filterInput = document.getElementById('mqttFilter');
                const clearBtn = document.getElementById('clearLogBtn');
                if (!filterInput || !clearBtn) {
                    console.warn('MQTT controls not found - skipping');
                    return;
                }
                filterInput.addEventListener('input', () => {
                    this.mqttFilter = filterInput.value.trim();
                    this.redrawMqttLog();
                });
                clearBtn.addEventListener('click', () => {
                    document.getElementById('mqttDebugger').innerHTML = '';
                });
            }

            startUptimeCounter() {
                setInterval(() => {
                    const uptime = Date.now() - this.startTime;
                    const hours = Math.floor(uptime / 3600000);
                    const minutes = Math.floor((uptime % 3600000) / 60000);
                    const seconds = Math.floor((uptime % 60000) / 1000);
                    document.getElementById('uptime').textContent = 
                        `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }, 1000);
            }

            handleMessage(data) {
                this.messageCount++;
                this.updateSystemMetrics();
                
                // Update audio data
                if (data.noise) {
                    this.updateAudioData(data.noise);
                }
                
                // Update room occupancy
                if (data.rooms) {
                    this.updateRoomStatus(data.rooms);
                }
                
                // Update buttons
                if (data.buttons) {
                    this.updateButtonStatus(data.buttons);
                }
                
                // Update fabrication level
                if (data.fabrication) {
                    document.getElementById('fabricationLevel').textContent = 
                        Math.round((data.fabrication.level || 0) * 100) + '%';
                }
            }

            handleDebugMessage(data) {
                // Handle raw MQTT debug messages
                this.addMQTTMessage(data.topic, data.payload);
                
                // Parse topic: party/<house>/<node>/<domain>/<signal>
                const parts = data.topic.split('/');
                if (parts.length >= 5) {
                    const nodeId = parts[2];
                    const domain = parts[3];
                    const signal = parts[4];
                    
                    // Update structured node data
                    if (signal === 'features') {
                        this.updateNodeData(nodeId, 'audio', data.payload);
                    } else if (signal === 'state' && domain === 'occupancy') {
                        this.updateNodeData(nodeId, 'occupancy', data.payload);
                    } else if (signal === 'state' && domain === 'ring') {
                        // LED ring state
                        this.updateLEDRing({...data.payload, node: nodeId});
                    } else if (signal === 'encoder') {
                        this.updateNodeData(nodeId, 'encoder', data.payload);
                    } else if (signal === 'button') {
                        // Button events need special handling for status display
                        this.buttonState[nodeId] = data.payload;
                        this.updateButtonStatus();
                    }
                }
                
                // Update specific data based on topic
                if (data.topic.includes('/audio/features')) {
                    const parts = data.topic.split('/');
                    const nodeId = parts.length >= 3 ? parts[2] : null;
                    this.updateAudioData(data.payload, nodeId);
                } else if (data.topic.includes('/occupancy/state')) {
                    // Extract node name from topic
                    const parts = data.topic.split('/');
                    if (parts.length >= 3) {
                        const nodeName = parts[2];
                        this.roomsState[nodeName] = data.payload;
                        this.updateRoomStatus(this.roomsState);
                    }
                } else if (data.topic.includes('/input/encoder')) {
                    const parts = data.topic.split('/');
                    const nodeId = parts.length >= 3 ? parts[2] : null;
                    this.updateEncoderData(data.payload, nodeId);
                } else if (data.topic.includes('/input/button')) {
                    const parts = data.topic.split('/');
                    const nodeId = parts.length >= 3 ? parts[2] : null;
                    this.updateButtonData(data.payload, nodeId);
                } else if (data.topic.includes('/ring/cmd')) {
                    this.updateLEDRing(data.payload);
                }
            }

            updateAudioData(noiseData, nodeId = null) {
                // Deprecated - now handled by updateNodeData
            }

            updateChartTimeRange() {
                // Deprecated - now using updateModularChart
                this.updateModularChart();
            }

            updateRoomStatus(rooms) {
                const table = document.getElementById('occupancyTable');
                if (!table) return;
                
                const nodes = Object.keys(rooms).sort();
                if (nodes.length === 0) {
                    table.innerHTML = '<p style="color:#888">No occupancy data yet...</p>';
                    return;
                }
                
                const tooltips = {
                    'occupied': 'Boolean occupancy state - true when motion detected',
                    'activity': 'Activity level 0.0-1.0 based on motion over last 10 seconds',
                    'transitions': 'Number of motion state changes in last second'
                };
                
                // Check if structure changed to avoid rebuilds
                const currentStructure = nodes.join(',');
                if (this.lastOccupancyTableStructure === currentStructure) {
                    // Only update values
                    const cells = table.querySelectorAll('td:not(.signal-name)');
                    let cellIdx = 0;
                    ['occupied', 'activity', 'transitions'].forEach(signal => {
                        nodes.forEach(node => {
                            const data = rooms[node];
                            let value = '--';
                            if (signal === 'occupied') {
                                value = data?.occupied ? '✅ YES' : '⬜ NO';
                            } else if (signal === 'activity') {
                                value = data?.activity !== undefined ? (data.activity * 100).toFixed(1) + '%' : '--';
                            } else if (signal === 'transitions') {
                                value = data?.transitions !== undefined ? data.transitions : '--';
                            }
                            if (cells[cellIdx]) {
                                cells[cellIdx].textContent = value;
                            }
                            cellIdx++;
                        });
                    });
                    return;
                }
                
                this.lastOccupancyTableStructure = currentStructure;
                
                let html = '<table class="status-table"><thead><tr><th>Signal</th>';
                nodes.forEach(node => {
                    html += `<th>${node}</th>`;
                });
                html += '</tr></thead><tbody>';
                
                ['occupied', 'activity', 'transitions'].forEach(signal => {
                    html += `<tr><td class="signal-name tooltip">${signal}`;
                    if (tooltips[signal]) {
                        html += `<span class="tooltiptext">${tooltips[signal]}</span>`;
                    }
                    html += `</td>`;
                    nodes.forEach(node => {
                        const data = rooms[node];
                        let value = '--';
                        if (signal === 'occupied') {
                            value = data?.occupied ? '✅ YES' : '⬜ NO';
                        } else if (signal === 'activity') {
                            value = data?.activity !== undefined ? (data.activity * 100).toFixed(1) + '%' : '--';
                        } else if (signal === 'transitions') {
                            value = data?.transitions !== undefined ? data.transitions : '--';
                        }
                        html += `<td>${value}</td>`;
                    });
                    html += '</tr>';
                });
                
                html += '</tbody></table>';
                table.innerHTML = html;
                
                // Add tooltip positioning
                setTimeout(() => {
                    table.querySelectorAll('.tooltip').forEach(el => {
                        const tooltip = el.querySelector('.tooltiptext');
                        if (tooltip) {
                            el.addEventListener('mouseenter', (e) => {
                                const rect = el.getBoundingClientRect();
                                const tooltipRect = tooltip.getBoundingClientRect();
                                let top = rect.top - tooltipRect.height - 10;
                                let left = rect.left + (rect.width / 2) - (tooltipRect.width / 2);
                                if (left < 10) left = 10;
                                if (left + tooltipRect.width > window.innerWidth - 10) {
                                    left = window.innerWidth - tooltipRect.width - 10;
                                }
                                if (top < 10) top = rect.bottom + 10;
                                tooltip.style.top = top + 'px';
                                tooltip.style.left = left + 'px';
                            });
                        }
                    });
                }, 100);
                
                document.getElementById('roomCount').textContent = nodes.length;
            }

            updateButtonStatus(buttons) {
                const buttonGrid = document.getElementById('buttonGrid');
                buttonGrid.innerHTML = '';
                
                Object.entries(buttons).forEach(([name, count]) => {
                    const buttonCard = document.createElement('div');
                    buttonCard.className = 'button-card';
                    buttonCard.innerHTML = `
                        <div class="sensor-label">${name}</div>
                        <div class="button-count">${count}</div>
                    `;
                    buttonGrid.appendChild(buttonCard);
                });
            }

            addMQTTMessage(topic, payload) {
                const logEl = document.getElementById('mqttDebugger');
                if (this.mqttFilter) {
                    const f = this.mqttFilter;
                    let pass = false;
                    try {
                        const rx = new RegExp(f);
                        pass = rx.test(topic);
                    } catch {
                        pass = topic.includes(f);
                    }
                    if (!pass) return;
                }
                const messageDiv = document.createElement('div');
                messageDiv.className = 'mqtt-message';
                
                const timestamp = new Date().toLocaleTimeString();
                messageDiv.innerHTML = `
                    <div class="mqtt-timestamp">${timestamp}</div>
                    <div class="mqtt-topic">${topic}</div>
                    <div class="mqtt-payload">${JSON.stringify(payload, null, 2)}</div>
                `;
                
                logEl.insertBefore(messageDiv, logEl.firstChild);
                
                while (logEl.children.length > 50) {
                    logEl.removeChild(logEl.lastChild);
                }
            }

            redrawMqttLog() {
                const log = document.getElementById('mqttDebugger');
                const all = Array.from(log.children).reverse();
                log.innerHTML = '';
                all.forEach(div => {
                    const topic = div.querySelector('.mqtt-topic')?.textContent || '';
                    let pass = true;
                    if (this.mqttFilter) {
                        try { pass = new RegExp(this.mqttFilter).test(topic); } catch { pass = topic.includes(this.mqttFilter); }
                    }
                    if (pass) log.insertBefore(div, log.firstChild);
                });
            }

            updateEncoderData(encoderData, nodeId = null) {
                if (nodeId) {
                    this.encoderState[nodeId] = encoderData;
                    this.updateEncoderStatus();
                }
            }

            updateButtonData(buttonData, nodeId = null) {
                if (nodeId) {
                    this.buttonState[nodeId] = buttonData;
                    this.updateButtonStatus();
                }
            }

            updateButtonStatus() {
                const buttonStatus = document.getElementById('buttonStatus');
                if (!buttonStatus) return;
                
                const nodes = Object.keys(this.buttonState).sort();
                if (nodes.length === 0) {
                    buttonStatus.innerHTML = '<p style="color:#888">No button events yet...</p>';
                    return;
                }
                
                let html = '<table class="status-table"><thead><tr><th>Node</th><th>State</th><th>Last Event</th><th>Timestamp</th></tr></thead><tbody>';
                
                nodes.forEach(node => {
                    const data = this.buttonState[node];
                    const state = data.pressed ? '🔴 PRESSED' : '⚪ RELEASED';
                    const event = data.event || '--';
                    const ts = data.ts_ms ? new Date(data.ts_ms).toLocaleTimeString() : '--';
                    html += `<tr><td class="signal-name">${node}</td><td>${state}</td><td>${event}</td><td>${ts}</td></tr>`;
                });
                
                html += '</tbody></table>';
                buttonStatus.innerHTML = html;
            }

            updateEncoderStatus() {
                const encoderStatus = document.getElementById('encoderStatus');
                if (!encoderStatus) return;
                
                const nodes = Object.keys(this.encoderState).sort();
                if (nodes.length === 0) {
                    encoderStatus.innerHTML = '<p style="color:#888">No encoder data yet...</p>';
                    return;
                }
                
                let html = '<table class="status-table"><thead><tr><th>Signal</th>';
                nodes.forEach(node => {
                    html += `<th>${node}</th>`;
                });
                html += '</tr></thead><tbody>';
                
                ['pos', 'delta'].forEach(signal => {
                    html += `<tr><td class="signal-name">${signal}</td>`;
                    nodes.forEach(node => {
                        const value = this.encoderState[node]?.[signal];
                        html += `<td>${value !== undefined ? value : '--'}</td>`;
                    });
                    html += '</tr>';
                });
                
                html += '</tbody></table>';
                encoderStatus.innerHTML = html;
            }

            updateAudioStatusTable() {
                const table = document.getElementById('audioStatusTable');
                if (!table) return;
                
                const audioNodes = Object.keys(this.nodeData).filter(n => this.nodeData[n].audio).sort();
                if (audioNodes.length === 0) {
                    table.innerHTML = '<p style="color:#888">No audio data yet...</p>';
                    return;
                }
                
                const tooltips = {
                    'rms': 'Root Mean Square - Overall sound intensity/loudness (0.0-1.0)',
                    'zcr': 'Zero-Crossing Rate - Frequency indicator. Low=bass, High=treble (0.0-1.0)',
                    'low': 'Low Band (~0-300 Hz) - Bass, rumble, footsteps',
                    'mid': 'Mid Band (~300-3000 Hz) - Voice, musical midrange',
                    'high': 'High Band (~3000+ Hz) - Treble, sibilance, cymbals'
                };
                
                // Check if structure has changed to avoid unnecessary rebuilds
                const currentStructure = audioNodes.join(',') + ':' + Object.keys(tooltips).join(',');
                if (this.lastAudioTableStructure === currentStructure) {
                    // Only update values, not structure
                    const cells = table.querySelectorAll('td:not(.signal-name)');
                    let cellIdx = 0;
                    ['rms', 'zcr', 'low', 'mid', 'high'].forEach(signal => {
                        audioNodes.forEach(node => {
                            const value = this.nodeData[node]?.audio?.[signal];
                            if (cells[cellIdx]) {
                                cells[cellIdx].textContent = value !== undefined ? value.toFixed(6) : '--';
                            }
                            cellIdx++;
                        });
                    });
                    return;
                }
                
                this.lastAudioTableStructure = currentStructure;
                
                let html = '<table class="status-table"><thead><tr><th>Signal</th>';
                audioNodes.forEach(node => {
                    html += `<th>${node}</th>`;
                });
                html += '</tr></thead><tbody>';
                
                ['rms', 'zcr', 'low', 'mid', 'high'].forEach(signal => {
                    html += `<tr><td class="signal-name tooltip">${signal}`;
                    if (tooltips[signal]) {
                        html += `<span class="tooltiptext">${tooltips[signal]}</span>`;
                    }
                    html += `</td>`;
                    audioNodes.forEach(node => {
                        const value = this.nodeData[node]?.audio?.[signal];
                        html += `<td>${value !== undefined ? value.toFixed(6) : '--'}</td>`;
                    });
                    html += '</tr>';
                });
                
                html += '</tbody></table>';
                table.innerHTML = html;
                
                // Add tooltip positioning on hover
                setTimeout(() => {
                    table.querySelectorAll('.tooltip').forEach(el => {
                        const tooltip = el.querySelector('.tooltiptext');
                        if (tooltip) {
                            el.addEventListener('mouseenter', (e) => {
                                const rect = el.getBoundingClientRect();
                                const tooltipRect = tooltip.getBoundingClientRect();
                                
                                // Position above the element
                                let top = rect.top - tooltipRect.height - 10;
                                let left = rect.left + (rect.width / 2) - (tooltipRect.width / 2);
                                
                                // Keep within window bounds
                                if (left < 10) left = 10;
                                if (left + tooltipRect.width > window.innerWidth - 10) {
                                    left = window.innerWidth - tooltipRect.width - 10;
                                }
                                if (top < 10) {
                                    // If no room above, show below
                                    top = rect.bottom + 10;
                                }
                                
                                tooltip.style.top = top + 'px';
                                tooltip.style.left = left + 'px';
                            });
                        }
                    });
                }, 100);
            }

            updateLEDRing(ringData) {
                const container = document.getElementById('ledRingContainer');
                if (!container) return;
                
                const nodeId = ringData.node || 'unknown';
                
                // Store ring data per node
                if (!this.ringState) this.ringState = {};
                this.ringState[nodeId] = ringData;
                
                // Get all nodes sorted
                const nodes = Object.keys(this.ringState).sort();
                if (nodes.length === 0) {
                    container.innerHTML = '<p style="color:#888">No ring data yet...</p>';
                    return;
                }
                
                const modeNames = {
                    0: 'OFF', 1: 'IDLE_BREATHING', 2: 'AUDIO_REACTIVE',
                    3: 'RAINBOW', 4: 'AURORA', 5: 'OCCUPANCY_PULSE'
                };
                
                // Build table with columns for each node
                let html = '<table class="status-table"><thead><tr><th>Metric</th>';
                nodes.forEach(node => {
                    html += `<th>${node}</th>`;
                });
                html += '</tr></thead><tbody>';
                
                // LED Ring visualization row
                html += '<tr><td class="signal-name">Ring</td>';
                nodes.forEach(node => {
                    const data = this.ringState[node];
                    const pixels = data.pixels || [];
                    const pixelCount = data.pixel_count || pixels.length || 8;
                    
                    html += '<td><svg width="120" height="120" viewBox="0 0 120 120" style="transform:rotate(-90deg)">';
                    html += '<circle cx="60" cy="60" r="50" fill="none" stroke="#333" stroke-width="1"/>';
                    
                    for (let i = 0; i < pixelCount; i++) {
                        const angle = (i / pixelCount) * 2 * Math.PI;
                        const x = 60 + Math.cos(angle) * 50;
                        const y = 60 + Math.sin(angle) * 50;
                        
                        // Decode RGB from 32-bit color value
                        const colorVal = pixels[i] !== undefined ? pixels[i] : 0;
                        let r = (colorVal >> 16) & 0xFF;
                        let g = (colorVal >> 8) & 0xFF;
                        let b = colorVal & 0xFF;
                        
                        // Boost saturation for visibility while preserving hue
                        if (r + g + b > 0) {
                            // Find max channel for brightness reference
                            const maxChannel = Math.max(r, g, b);
                            const brightness = maxChannel / 255;
                            
                            // Scale up to full saturation for visualization
                            if (maxChannel > 0) {
                                r = Math.min(255, Math.round(r * (255 / maxChannel) * 0.8));
                                g = Math.min(255, Math.round(g * (255 / maxChannel) * 0.8));
                                b = Math.min(255, Math.round(b * (255 / maxChannel) * 0.8));
                            }
                            
                            const color = `rgb(${r},${g},${b})`;
                            const glowIntensity = brightness * 8;
                            const glow = brightness > 0.1 ? `drop-shadow(0 0 ${glowIntensity}px ${color})` : '';
                            
                            html += `<circle cx="${x}" cy="${y}" r="5" fill="${color}" style="filter:${glow}"/>`;
                        } else {
                            html += `<circle cx="${x}" cy="${y}" r="5" fill="#111"/>`;
                        }
                    }
                    html += '</svg></td>';
                });
                html += '</tr>';
                
                // Mode row
                html += '<tr><td class="signal-name">Mode</td>';
                nodes.forEach(node => {
                    const mode = this.ringState[node].mode || 0;
                    html += `<td>${modeNames[mode] || mode}</td>`;
                });
                html += '</tr>';
                
                // Brightness row
                html += '<tr><td class="signal-name">Brightness</td>';
                nodes.forEach(node => {
                    const brightness = this.ringState[node].brightness || 0;
                    html += `<td>${(brightness * 100).toFixed(0)}%</td>`;
                });
                html += '</tr>';
                
                // Speed row
                html += '<tr><td class="signal-name">Speed</td>';
                nodes.forEach(node => {
                    const speed = this.ringState[node].speed || 1.0;
                    html += `<td>${speed.toFixed(2)}x</td>`;
                });
                html += '</tr>';
                
                html += '</tbody></table>';
                container.innerHTML = html;
            }


            updateSystemMetrics() {
                document.getElementById('messageCount').textContent = this.messageCount;
                document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
            }

            updateConnectionStatus(status) {
                const statusEl = document.getElementById('connectionStatus');
                statusEl.textContent = status === 'connected' ? 'Connected' : 
                                     status === 'disconnected' ? 'Disconnected' : 'Error';
                statusEl.className = `connection-status ${status}`;
            }

            updateStatusIndicator(elementId, connected) {
                const indicator = document.getElementById(elementId);
                indicator.className = `status-indicator ${connected ? 'connected' : 'error'}`;
            }


            // ===== MODULAR SIGNAL PLOTTING =====

            initSignalControls() {
                const addBtn = document.getElementById('addSignalBtn');
                if (!addBtn) {
                    console.error('addSignalBtn not found');
                    return;
                }
                addBtn.addEventListener('click', () => this.addSignal());
                
                // Pre-populate with node1 and node2 audio RMS for initial view
                setTimeout(() => {
                    if (this.activeSignals.length === 0) {
                        this.addSignalProgrammatic('node1', 'audio.rms', this.colorPalette[0]);
                        this.addSignalProgrammatic('node2', 'audio.rms', this.colorPalette[1]);
                    }
                }, 1000);
            }

            addSignal() {
                const nodeSelector = document.getElementById('nodeSelector');
                const signalSelector = document.getElementById('signalSelector');
                
                const node = nodeSelector.value;
                const path = signalSelector.value;
                
                if (!node || !path) {
                    alert('Please select both a node and a signal');
                    return;
                }
                
                const color = this.colorPalette[this.activeSignals.length % this.colorPalette.length];
                this.addSignalProgrammatic(node, path, color);
            }

            addSignalProgrammatic(node, path, color) {
                const id = this.signalIdCounter++;
                const signal = {
                    id,
                    node,
                    path,
                    color,
                    visible: true,
                    data: []
                };
                
                this.activeSignals.push(signal);
                this.renderSignalList();
                this.saveSignalConfig();
                this.updateModularChart();
            }

            removeSignal(id) {
                this.activeSignals = this.activeSignals.filter(s => s.id !== id);
                this.renderSignalList();
                this.saveSignalConfig();
                this.updateModularChart();
            }

            toggleSignalVisibility(id) {
                const signal = this.activeSignals.find(s => s.id === id);
                if (signal) {
                    signal.visible = !signal.visible;
                    this.renderSignalList();
                    this.saveSignalConfig();
                    this.updateModularChart();
                }
            }

            changeSignalColor(id) {
                const signal = this.activeSignals.find(s => s.id === id);
                if (!signal) return;
                
                const newColor = prompt('Enter hex color (e.g., #00ff88):', signal.color);
                if (newColor && /^#[0-9A-Fa-f]{6}$/.test(newColor)) {
                    signal.color = newColor;
                    this.renderSignalList();
                    this.saveSignalConfig();
                    this.updateModularChart();
                }
            }

            renderSignalList() {
                const signalList = document.getElementById('signalList');
                signalList.innerHTML = '';
                
                // Sort signals alphabetically by node/path
                const sorted = [...this.activeSignals].sort((a, b) => {
                    const aKey = `${a.node}/${a.path}`;
                    const bKey = `${b.node}/${b.path}`;
                    return aKey.localeCompare(bKey);
                });
                
                sorted.forEach(signal => {
                    const tag = document.createElement('div');
                    tag.className = 'signal-tag';
                    tag.style.opacity = signal.visible ? '1' : '0.5';
                    tag.innerHTML = `
                        <div class="color-dot" style="background:${signal.color}" title="Click to change color"></div>
                        <span style="cursor:pointer" title="Click to toggle visibility">${signal.node}/${signal.path}</span>
                        <span class="remove-btn" title="Remove signal">×</span>
                    `;
                    
                    tag.querySelector('.color-dot').addEventListener('click', () => this.changeSignalColor(signal.id));
                    tag.querySelector('span:nth-child(2)').addEventListener('click', () => this.toggleSignalVisibility(signal.id));
                    tag.querySelector('.remove-btn').addEventListener('click', () => this.removeSignal(signal.id));
                    
                    signalList.appendChild(tag);
                });
            }

            updateNodeData(nodeId, domain, payload) {
                if (!this.nodeData[nodeId]) {
                    this.nodeData[nodeId] = {};
                    this.discoveredNodes.add(nodeId);
                    this.updateNodeSelector();
                }
                
                if (!this.nodeData[nodeId][domain]) {
                    this.nodeData[nodeId][domain] = {};
                }
                
                Object.assign(this.nodeData[nodeId][domain], payload);
                
                // Update signal data for active signals
                const now = new Date();
                this.activeSignals.forEach(signal => {
                    if (signal.node === nodeId) {
                        const value = this.getSignalValue(nodeId, signal.path);
                        if (value !== null && value !== undefined) {
                            signal.data.push({x: now, y: value});
                            // Keep last 1 hour of data max
                            const hourAgo = new Date(now.getTime() - 3600000);
                            signal.data = signal.data.filter(d => d.x >= hourAgo);
                        }
                    }
                });
                
                // Update status tables
                if (domain === 'audio') {
                    this.updateAudioStatusTable();
                } else if (domain === 'encoder') {
                    this.encoderState[nodeId] = payload;
                    this.updateEncoderStatus();
                }
            }

            getSignalValue(nodeId, path) {
                const parts = path.split('.');
                let obj = this.nodeData[nodeId];
                
                for (const part of parts) {
                    if (obj === undefined || obj === null) return null;
                    obj = obj[part];
                }
                
                // Convert boolean to number for plotting
                if (typeof obj === 'boolean') return obj ? 1 : 0;
                if (typeof obj === 'number') return obj;
                return null;
            }

            updateNodeSelector() {
                const nodeSelector = document.getElementById('nodeSelector');
                const currentValue = nodeSelector.value;
                
                nodeSelector.innerHTML = '<option value="">Select Node...</option>';
                Array.from(this.discoveredNodes).sort().forEach(nodeId => {
                    const opt = document.createElement('option');
                    opt.value = nodeId;
                    opt.textContent = nodeId;
                    nodeSelector.appendChild(opt);
                });
                
                if (currentValue) nodeSelector.value = currentValue;
            }

            updateModularChart() {
                if (!this.audioChart || !this.audioChart.data) return;
                
                const now = new Date();
                const cutoff = new Date(now.getTime() - this.currentTimeRange * 1000);
                
                // Build datasets from active signals (sorted alphabetically)
                const datasets = [];
                const sorted = [...this.activeSignals].sort((a, b) => {
                    const aKey = `${a.node}/${a.path}`;
                    const bKey = `${b.node}/${b.path}`;
                    return aKey.localeCompare(bKey);
                });
                
                sorted.forEach(signal => {
                    if (!signal.visible) return;
                    
                    const filteredData = signal.data.filter(d => d.x >= cutoff);
                    datasets.push({
                        label: `${signal.node}/${signal.path}`,
                        data: filteredData,
                        borderColor: signal.color,
                        backgroundColor: 'transparent',
                        tension: 0.1,
                        parsing: {
                            xAxisKey: 'x',
                            yAxisKey: 'y'
                        }
                    });
                });
                
                this.audioChart.data.datasets = datasets;
                
                // Keep x-axis time range consistent
                if (this.audioChart.options && this.audioChart.options.scales && this.audioChart.options.scales.x) {
                    this.audioChart.options.scales.x.min = cutoff;
                    this.audioChart.options.scales.x.max = now;
                }
                
                this.audioChart.update('none');
            }

            saveSignalConfig() {
                const config = this.activeSignals.map(s => ({
                    node: s.node,
                    path: s.path,
                    color: s.color,
                    visible: s.visible
                }));
                localStorage.setItem('wm-debug-signals', JSON.stringify(config));
            }

            loadSignalConfig() {
                try {
                    const stored = localStorage.getItem('wm-debug-signals');
                    if (stored) {
                        const config = JSON.parse(stored);
                        config.forEach(s => {
                            this.addSignalProgrammatic(s.node, s.path, s.color);
                            const signal = this.activeSignals[this.activeSignals.length - 1];
                            if (signal) signal.visible = s.visible;
                        });
                        this.renderSignalList();
                    }
                } catch (e) {
                    console.error('Failed to load signal config:', e);
                }
            }
        }

        // Initialize the debug UI when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new WhisperingMachineDebugUI();
        });
    </script>
</body>
</html>

