# Whispering Machine — ESP32 Node Firmware

Small ESP32 nodes that sense **sound intensity (INMP441)** and **motion (PIR)**, expose a **rotary encoder + push**, and drive a **WS2812 LED ring** for local feedback. Nodes publish to MQTT and accept ring commands, feeding the party-tracker dashboard.

## Features

* **Audio RMS** from I²S mic (INMP441), ~10 Hz publish
* **PIR occupancy** (~1 Hz)
* **Rotary encoder** (A/B) + **push button** with debounced events
* **WS2812 ring control** (local feedback + remote commands)
* **MQTT** pub/sub with DRY topic scheme
* **OTA updates** via ArduinoOTA
* DRY **PlatformIO** config with `secrets.ini` (not committed)

---

## Hardware & Wiring (per node)

**ESP32 Dev Board (ESP-WROOM-32)**

* **INMP441 (I²S)**

  * `BCLK → GPIO26`
  * `LRCL → GPIO25`
  * `DOUT → GPIO22`
  * `3V3 → 3V3`, `GND → GND`

* **PIR (AM312)**

  * `OUT → GPIO27`
  * `VCC → 3V3`, `GND → GND`

* **Rotary Encoder (EC11)**

  * `A → GPIO14 (INPUT_PULLUP)`
  * `B → GPIO12 (INPUT_PULLUP)`
  * `C (common) → GND`
  * `SW → GPIO15 (INPUT_PULLUP)`
  * `SW other pin → GND`
  * *(Optional HW debounce: 0.1 µF from A→GND and B→GND)*

* **LED Ring (WS2812, 5 V)**

  * `DIN ← GPIO5` via **330 Ω** series resistor
  * `5 V ← 5 V supply`, `GND ← common GND`
  * *(Optional) bulk cap 220–1000 µF across 5 V/GND near ring*

* **Power**

  * Prefer **5 V wall USB adapters** → `5V/VIN` on ESP32
  * **Common ground** between everything

> Pins come from `build_flags` in `config/common.ini`. Change them centrally if needed.

---

## Repo Layout (node-side)

```
firmware/wm_node/
  platformio.ini
  config/
    common.ini     # shared build flags, lib_deps, pins
    nodes.ini      # env inheritance & per-node envs (USB/OTA)
  secrets.ini      # NOT committed (Wi-Fi creds)
  src/
    main.cpp       # orchestration
    config.h
    topics.h
    wifi_ota.{h,cpp}
    mqtt_bus.{h,cpp}
    ring.{h,cpp}
    i2s_audio.{h,cpp}
    pir.{h,cpp}
    encoder.{h,cpp}
    wm_version.h   # generated by scripts/bump_version.sh
```

---

## PlatformIO Config

### 1) `secrets.ini` (local, gitignored)

```ini
[secrets]
WM_SSID = YourWiFiSSID
WM_PASS = YourWiFiPassword
```

### 2) `platformio.ini`

```ini
[platformio]
default_envs = node1-usb
extra_configs =
  config/common.ini
  config/nodes.ini
  secrets.ini

[env]
platform = espressif32
board = esp32dev
framework = arduino
monitor_speed = 115200
```

### 3) `config/common.ini` (DRY pins + deps)

```ini
[common_env_data]
build_flags =
  -D WM_SSID=\"${secrets.WM_SSID}\"
  -D WM_PASS=\"${secrets.WM_PASS}\"
  -D WM_BROKER_HOST=\"192.168.50.69\"
  -D WM_BROKER_PORT=1884
  -D WM_HOUSE_ID=\"houseA\"
  -D I2S_BCLK=26
  -D I2S_LRCL=25
  -D I2S_DOUT=22
  -D PIR_PIN=27
  -D NEOPIXEL_PIN=5
  -D NEOPIXEL_COUNT=8
  -D ENCODER_PIN_A=14
  -D ENCODER_PIN_B=12
  -D ENCODER_PIN_SW=15
lib_deps =
  adafruit/Adafruit NeoPixel@^1.12.3
  knolleary/PubSubClient@^2.8
  bblanchon/ArduinoJson@^6.21.3
```

### 4) `config/nodes.ini` (per-node envs)

```ini
[env:base-usb]
extends = env
build_flags = ${common_env_data.build_flags}
lib_deps   = ${common_env_data.lib_deps}
upload_speed = 921600

[env:base-ota]
extends = env
build_flags = ${common_env_data.build_flags}
lib_deps   = ${common_env_data.lib_deps}
upload_protocol = espota

[env:node1-usb]
extends = env:base-usb
build_flags = ${common_env_data.build_flags} -D WM_NODE_ID=\"node1\"

[env:node1-ota]
extends = env:base-ota
build_flags = ${common_env_data.build_flags} -D WM_NODE_ID=\"node1\"
upload_port = 192.168.50.210

; Duplicate for node2..node5 with new WM_NODE_ID and upload_port
```

---

## Build & Upload

### First-time (USB)

```bash
pio run -e node2-usb -t upload        # change env to your node
pio device monitor -e node2-usb
```

### Subsequent (OTA)

```bash
pio run -e node2-ota -t upload
```

> TIP: Use repo scripts:
>
> * `scripts/flash_usb.sh node2 /dev/cu.usbserial-0001`
> * `scripts/build_all.sh` (uploads to all `*-ota` envs)
> * `scripts/bump_version.sh` (stamps `wm_version.h` with git sha + UTC build time)

---

## MQTT Topics

**Base:** `party/<house>/<node>`

* **Publish**

  * `audio/features` → `{"rms":float,"zcr":0,"low":0,"mid":0,"high":0,"ts_ms":int}`
  * `occupancy/state` → `{"occupied":bool,"ts_ms":int}`
  * `input/encoder` → `{"pos":int,"delta":int,"ts_ms":int}`
  * `input/button` → `{"pressed":bool,"ts_ms":int}`
  * `sys/heartbeat` → `{"ts_ms":int}`

* **Subscribe**

  * `ring/cmd` → e.g. `{"on":true,"b":0.4}`

Quick test:

```bash
mosquitto_sub -h 192.168.50.69 -p 1884 -t 'party/houseA/+/+' -v
```

---

## Runtime Notes

* Heartbeat every **5s** (also twinkles a ring pixel)
* Audio RMS publish at ~**10 Hz**
* PIR publish at **1 Hz**
* Encoder/Btn publishes on change (coalesced ~150 ms)
* OTA handler runs in `loop()`; keep loops non-blocking

---

## Troubleshooting

* **No serial text / gibberish:** `pio device monitor -b 115200` (match monitor_speed)
* **Wi-Fi never connects:** verify `secrets.ini`, 2.4 GHz SSID, RSSI; watch status codes
* **No MQTT:** ensure broker/port reachable; watch `[MQTT] rc=...` codes
* **LED ring not responding:** common ground, 330 Ω on DIN, try lower brightness
* **Encoder bouncing/wrong counts:** add 0.1 µF caps on A/B to GND or increase coalesce window
* **OTA fails:** node must be on Wi-Fi and reachable at `upload_port`; try a fresh USB flash once

---

## Extending

* Add local behaviors (e.g., ring “mood” based on activity)
* Extra inputs: arcade buttons, toggles (publish to `input/*`)
* Per-room personalities: change LED palette or encoder semantics via MQTT
